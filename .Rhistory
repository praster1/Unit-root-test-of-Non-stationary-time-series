## z51     0.0792485  1.0824733  0.2856339  0.277   0.7814
## z61    -0.0702048  0.9322029  0.2557463 -0.275   0.7837
## z7      0.0000440  1.0000440  0.0004235  0.104   0.9173
## z81     0.4618598  1.5870228  0.3386689  1.364   0.1726
## z101    0.5145619  1.6729055  0.3330479  1.545   0.1223
## ---
## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
##
##        exp(coef) exp(-coef) lower .95 upper .95
## group2   1.28918     0.7757   0.55044   3.01937
## group3   1.69559     0.5898   0.74478   3.86023
## ta       0.99821     1.0018   0.99747   0.99894
## tc       0.99402     1.0060   0.99197   0.99607
## tp       0.99943     1.0006   0.99696   1.00190
## dc1      0.02779    35.9887   0.01056   0.07314
## dp1      0.29327     3.4098   0.11375   0.75613
## z1       1.01097     0.9892   0.96635   1.05764
## z2       0.98459     1.0157   0.94670   1.02399
## z31      1.01635     0.9839   0.62506   1.65258
## z41      1.03404     0.9671   0.60642   1.76319
## z51      1.08247     0.9238   0.61842   1.89474
## z61      0.93220     1.0727   0.56470   1.53887
## z7       1.00004     1.0000   0.99921   1.00087
## z81      1.58702     0.6301   0.81716   3.08218
## z101     1.67291     0.5978   0.87092   3.21338
##
## Concordance= 0.926  (se = 0.034 )
## Rsquare= 0.806   (max possible= 0.995 )
## Likelihood ratio test= 224.6  on 16 df,   p=0
## Wald test            = 107.5  on 16 df,   p=1.332e-15
## Score (logrank) test = 211.7  on 16 df,   p=0
cox_fit_bmt <- survfit(cox_bmt)
# plot(cox_fit_bmt)
Random Forests Model
data(bmt)
bmt
## Check for violation of proportional hazard (constant HR over wordTime)
res.zph1 = cox.zph(res)
plot(res.zph1, df=2)
## Check for violation of proportional hazard (constant HR over wordTime)
res.zph1 = cox.zph(res)
plot(res.zph1, df=2)
pbc
D = pbc[,c(5, 11, 10, 19, 13)]
pbc
?pbc
library(survival)
library(rms)
support = 0
# D[D<support] = 0
D = pbc[,c(5, 11, 10, 19, 13)]
D[,2] = log(D[,2])
D[,4] = log(D[,4])
Time = pbc[,2]
Status = pbc[,3]
par(mfrow = c(1, ncol(D)))
for (i in 1:ncol(D))
{
res0 = coxph(Surv(Time, Status) ~ D[,i])
exp(res0$coefficients)
summary(res0)
## Displays a graph of the scaled Schoenfeld residuals, along with a smooth curve.
fit = survfit(res0)
plot(fit, col=rainbow(ncol(D))[i])
# library(survminer)
# ggsurvplot(fit, conf.int = TRUE, palette = "Dark2", censor = FALSE, surv.median.line = "hv", data=B)
}
library(survival)
library(rms)
support = 0
# D[D<support] = 0
D = pbc[,c(5, 11, 10, 19, 13)]
D[,2] = log(D[,2])
D[,4] = log(D[,4])
Time = pbc[,2]
Status = pbc[,3]
par(mfrow = c(1, ncol(D)))
for (i in 1:ncol(D))
{
res0 = coxph(Surv(Time, Status) ~ D[,i])
exp(res0$coefficients)
summary(res0)
## Displays a graph of the scaled Schoenfeld residuals, along with a smooth curve.
fit = survfit(res0)
plot(fit, col=rainbow(ncol(D))[i])
# library(survminer)
# ggsurvplot(fit, conf.int = TRUE, palette = "Dark2", censor = FALSE, surv.median.line = "hv", data=B)
}
library(survival)
library(rms)
support = 0
# D[D<support] = 0
D = pbc[,c(5, 11, 10, 19, 13)]
D[,2] = log(D[,2])
D[,4] = log(D[,4])
Time = pbc[,2]
Status = pbc[,3]
par(mfrow = c(1, ncol(D)))
for (i in 1:ncol(D))
{
res0 = coxph(Surv(Time, Status) ~ D[,i])
exp(res0$coefficients)
summary(res0)
## Displays a graph of the scaled Schoenfeld residuals, along with a smooth curve.
res.zph1 = cox.zph(res0)
plot(res.zph1, df=2)
# library(survminer)
# ggsurvplot(fit, conf.int = TRUE, palette = "Dark2", censor = FALSE, surv.median.line = "hv", data=B)
}
pbc
?pbc
coxph(Surv(time, status=2)~age + log(bili) + edema + log(protime) + albumin, data=pbc)
res = coxph(Surv(time, status==2)~age + log(bili) + edema + log(protime) + albumin, data=pbc)
res
5.4*100/0.5
5.4*100/0.05
5.4*1/0.05
exptest = function(x, lambda)
{
lambda * exp(-lambda * x)
)
exptest = function(x, lambda)
{
lambda * exp(-lambda * x)
)
exptest = function(x, lambda)
{
lambda * exp(-lambda * x)
}
plot(exptest(1. c(1:100)))
plot(exptest(1. 1:100)))
exptest(1. 1:100))
exptest(1, 1:100))
exptest(1, 1:100)
plot(exptest(1, 1:100))
plot(exptest(1, 1:10))
plot(exptest(1, 1:10), type="l")
exptest = function(x, lambda)
{
1/lambda * exp(-(1/lambda) * x)
}
plot(exptest(1, 1:10), type="l")
exptest = function(x, lambda)
{
-lambda * exp(-lambda * x)
}
plot(exptest(1, 1:10), type="l")
exptest = function(x, lambda)
{
-lambda * exp(-lambda * x)
}
plot(exptest(0.5, 1:10), type="l")
exptest = function(x, lambda)
{
-lambda * exp(-lambda * x)
}
plot(exptest(0.5, seq(1, 10, length=1000), type="l")
exptest = function(x, lambda)
{
-lambda * exp(lambda * x)
}
plot(exptest(0.5, seq(1, 10, length=1000), type="l")
exptest = function(x, lambda)
{
-lambda * exp(lambda * x)
}
plot(exptest(0.5, seq(1, 10, length=1000), type="l")
exptest = function(x, lambda)
{
-lambda * exp(lambda * x)
}
exptest = function(x, lambda)
{
-lambda * exp(lambda * x)
}
exptest = function(x, lambda)
{
-lambda * exp(lambda * x)
}
plot(exptest(0.5, seq(1, 10, length=1000), type="l")
plot(exptest(0.5, seq(1, 10, length=1000), type="l"))
plot(exptest(0.5, seq(1, 10, length=1000)) type="l")
plot(exptest(0.5, seq(1, 10, length=1000)), type="l")
plot(exptest(2, seq(1, 10, length=1000)), type="l")
plot(exptest(0.9, seq(1, 10, length=1000)), type="l")
plot(exptest(0.5, seq(1, 10, length=1000)), type="l")
install.packages("shiny")
library(shiny)
# Define UI for application that draws a histogram
ui <- fluidPage(
# Application title
titlePanel("Old Faithful Geyser Data"),
# Sidebar with a slider input for number of bins
sidebarLayout(
sidebarPanel(
sliderInput("bins",
"Number of bins:",
min = 1,
max = 50,
value = 30)
),
# Show a plot of the generated distribution
mainPanel(
plotOutput("distPlot")
)
)
)
# Define server logic required to draw a histogram
server <- function(input, output) {
output$distPlot <- renderPlot({
# generate bins based on input$bins from ui.R
x    <- faithful[, 2]
bins <- seq(min(x), max(x), length.out = input$bins + 1)
# draw the histogram with the specified number of bins
hist(x, breaks = bins, col = 'darkgray', border = 'white')
})
}
# Run the application
shinyApp(ui = ui, server = server)
faithful
install.packages("nortest")
siz=50      # sample size
nsig=0.05   # significance level
n=7         # mosaic size (nxn), with 1<n<50. If n is even, then n=n+1
nsim=1000   # number of simulations
test="SW"   # Type of test, AD=Anderson-Darling,SW=Shapiro-Wilks,KS=Kolmogorov-Smirnov
label=T     # T= type II error is shown in each cell; F= type II error is not shown
Opt=0       # 0: Standard; 1: Curve always black; 2: Only mosaic (without test)
#########################################################
library(nortest)
####Random generation for SEPD
rsepd=function(n,mu=0,sigma=1,alpha=0.5,p=2){
kp=1/(2*gamma(1+1/p)*p^(1/p))
u=runif(n)
w=rgamma(n,shape=1/p,scale=1)
y=ifelse(u>alpha,1-alpha,-alpha)*(w^(1/p))/gamma(1+1/p)
y=y/kp
A=2*p^(1/p)*((1-alpha)^2-alpha^2)*gamma(2/p)/gamma(1/p)
A2=(2*p^(1/p))^2*((1-alpha)^3+alpha^3)*gamma(3/p)/gamma(1/p)
B=sqrt(A2-A^2)
mu+sigma*(y-A)/B
}
####Density function for SEPD
dsepd=function(x,mu=0,sigma=1,alpha=0.5,p=2){
A=2*p^(1/p)*((1-alpha)^2-alpha^2)*gamma(2/p)/gamma(1/p)
A2=(2*p^(1/p))^2*((1-alpha)^3+alpha^3)*gamma(3/p)/gamma(1/p)
B=sqrt(A2-A^2)
y=A+B*(x-mu)/sigma
kp=1/(gamma(1+1/p)*(2*p^(1/p)))
kp*exp(-(abs(y/(2*ifelse(x<mu-sigma*A/B,alpha,1-alpha)))^p)/p)*B/sigma
}
###Monte Carlo p-value for godness-of-fit statistics
et2_MC=function(siz,nsim,mu,sigma,alpha,p,nsig,test){
ysim=matrix(rsepd(siz*nsim,mu=mu,sigma=sigma,alpha=alpha,p=p),nc=siz)
prova=switch(test,
AD = function(el) ad.test(el)$p.value,
SW = function(el) shapiro.test(el)$p.value,
KS = function(el) lillie.test(el)$p.value)
res=apply(ysim,1,prova)
length(res[res>nsig])/nsim
}
#### Mosaic function
mosaic=function(siz,n,nsim=499,nsig=0.05,test="AD",label=F,Opt=0){
if (n<=1 | n>=50) {
stop("n must be a value between 2 and 49\n")
}
mu=0
sigma=1
if (n%%2==0) n=n+1
cex1=c(1.2,1,0.8,0.7,0.6)
old.par=par(mfrow = c(n,n), xaxt="n", yaxt="n", mar=c(0,0,0,0), cex=cex1[findInterval(n,c(1,5,10,15,25,9999))], xaxs="i", yaxs="i")
s=3.5
ymax=c(0,1/sigma)
j=(log10(50)/log10(2))^(1/(n/2-0.5))
alfa=(0:(n-1))/(n-1)
alfa[alfa==0]=1e-12
alfa[alfa==1]=1-1e-12
p=c(1,2,50)
if (n>3) p=c(1,2^(1/(j^(((n-3)/2):1))),2,2^(j^((1:(n/2-0.5)))))
graf1=function(param,label){
x=seq(from=mu-s*sigma,to=mu+s*sigma,length.out=101)
plot(0,0,xlim=c(mu-s*sigma,mu+s*sigma),ylim=ymax,type="n",axes=F)
pvalue=round(et2_MC(siz=siz,nsim=nsim,mu=mu,sigma=sigma,alpha=param[1],p=param[2],nsig=nsig,test=test),2)
id=findInterval(pvalue,c(0,0.05,0.25,0.5,1))
colo=gray(c(0.9,0.85,0.4,0.2,0))[id]
if(id>1) rect(mu-s*sigma,0,mu+s*sigma,ymax[2],col=colo)
coline=switch(Opt+1, ifelse(id>2,"white","black"),"black","black")
curve(dsepd(x,mu=mu,sigma=sigma,alpha=param[1],p=param[2]),col=coline,add=T)
if (param[1]==0.5 & param[2]==2) box(lwd=2,col="white") else box()
if (label) text(mu,ymax[2]*0.5,round(pvalue,2),col=ifelse(id>2,"white","black"))
}
graf2=function(param,label){
x=seq(from=mu-s*sigma,to=mu+s*sigma,length.out=101)
plot(0,0,xlim=c(mu-s*sigma,mu+s*sigma),ylim=ymax,type="n",axes=F)
curve(dsepd(x,mu=mu,sigma=sigma,alpha=param[1],p=param[2]),col="black",add=T)
box()
}
if (Opt==2) graf=graf2 else graf=graf1
apply(expand.grid(alfa,p),1,graf,label=label)
par(old.par)
}
mosaic(siz,n,nsim,nsig,test,label,Opt)
#########################################################
# Supplementary material that accompanies the article:  #
#    Visualizing Type II Error in Normality Tests       #
#########################################################
# You can change the values of the following parameters:
siz=100      # sample size
nsig=0.05   # significance level
n=7         # mosaic size (nxn), with 1<n<50. If n is even, then n=n+1
nsim=1000   # number of simulations
test="SW"   # Type of test, AD=Anderson-Darling,SW=Shapiro-Wilks,KS=Kolmogorov-Smirnov
label=T     # T= type II error is shown in each cell; F= type II error is not shown
Opt=0       # 0: Standard; 1: Curve always black; 2: Only mosaic (without test)
#########################################################
library(nortest)
####Random generation for SEPD
rsepd=function(n,mu=0,sigma=1,alpha=0.5,p=2){
kp=1/(2*gamma(1+1/p)*p^(1/p))
u=runif(n)
w=rgamma(n,shape=1/p,scale=1)
y=ifelse(u>alpha,1-alpha,-alpha)*(w^(1/p))/gamma(1+1/p)
y=y/kp
A=2*p^(1/p)*((1-alpha)^2-alpha^2)*gamma(2/p)/gamma(1/p)
A2=(2*p^(1/p))^2*((1-alpha)^3+alpha^3)*gamma(3/p)/gamma(1/p)
B=sqrt(A2-A^2)
mu+sigma*(y-A)/B
}
####Density function for SEPD
dsepd=function(x,mu=0,sigma=1,alpha=0.5,p=2){
A=2*p^(1/p)*((1-alpha)^2-alpha^2)*gamma(2/p)/gamma(1/p)
A2=(2*p^(1/p))^2*((1-alpha)^3+alpha^3)*gamma(3/p)/gamma(1/p)
B=sqrt(A2-A^2)
y=A+B*(x-mu)/sigma
kp=1/(gamma(1+1/p)*(2*p^(1/p)))
kp*exp(-(abs(y/(2*ifelse(x<mu-sigma*A/B,alpha,1-alpha)))^p)/p)*B/sigma
}
###Monte Carlo p-value for godness-of-fit statistics
et2_MC=function(siz,nsim,mu,sigma,alpha,p,nsig,test){
ysim=matrix(rsepd(siz*nsim,mu=mu,sigma=sigma,alpha=alpha,p=p),nc=siz)
prova=switch(test,
AD = function(el) ad.test(el)$p.value,
SW = function(el) shapiro.test(el)$p.value,
KS = function(el) lillie.test(el)$p.value)
res=apply(ysim,1,prova)
length(res[res>nsig])/nsim
}
#### Mosaic function
mosaic=function(siz,n,nsim=499,nsig=0.05,test="AD",label=F,Opt=0){
if (n<=1 | n>=50) {
stop("n must be a value between 2 and 49\n")
}
mu=0
sigma=1
if (n%%2==0) n=n+1
cex1=c(1.2,1,0.8,0.7,0.6)
old.par=par(mfrow = c(n,n), xaxt="n", yaxt="n", mar=c(0,0,0,0), cex=cex1[findInterval(n,c(1,5,10,15,25,9999))], xaxs="i", yaxs="i")
s=3.5
ymax=c(0,1/sigma)
j=(log10(50)/log10(2))^(1/(n/2-0.5))
alfa=(0:(n-1))/(n-1)
alfa[alfa==0]=1e-12
alfa[alfa==1]=1-1e-12
p=c(1,2,50)
if (n>3) p=c(1,2^(1/(j^(((n-3)/2):1))),2,2^(j^((1:(n/2-0.5)))))
graf1=function(param,label){
x=seq(from=mu-s*sigma,to=mu+s*sigma,length.out=101)
plot(0,0,xlim=c(mu-s*sigma,mu+s*sigma),ylim=ymax,type="n",axes=F)
pvalue=round(et2_MC(siz=siz,nsim=nsim,mu=mu,sigma=sigma,alpha=param[1],p=param[2],nsig=nsig,test=test),2)
id=findInterval(pvalue,c(0,0.05,0.25,0.5,1))
colo=gray(c(0.9,0.85,0.4,0.2,0))[id]
if(id>1) rect(mu-s*sigma,0,mu+s*sigma,ymax[2],col=colo)
coline=switch(Opt+1, ifelse(id>2,"white","black"),"black","black")
curve(dsepd(x,mu=mu,sigma=sigma,alpha=param[1],p=param[2]),col=coline,add=T)
if (param[1]==0.5 & param[2]==2) box(lwd=2,col="white") else box()
if (label) text(mu,ymax[2]*0.5,round(pvalue,2),col=ifelse(id>2,"white","black"))
}
graf2=function(param,label){
x=seq(from=mu-s*sigma,to=mu+s*sigma,length.out=101)
plot(0,0,xlim=c(mu-s*sigma,mu+s*sigma),ylim=ymax,type="n",axes=F)
curve(dsepd(x,mu=mu,sigma=sigma,alpha=param[1],p=param[2]),col="black",add=T)
box()
}
if (Opt==2) graf=graf2 else graf=graf1
apply(expand.grid(alfa,p),1,graf,label=label)
par(old.par)
}
mosaic(siz,n,nsim,nsig,test,label,Opt)
siz=200      # sample size
nsig=0.05   # significance level
n=7         # mosaic size (nxn), with 1<n<50. If n is even, then n=n+1
nsim=1000   # number of simulations
test="SW"   # Type of test, AD=Anderson-Darling,SW=Shapiro-Wilks,KS=Kolmogorov-Smirnov
label=T     # T= type II error is shown in each cell; F= type II error is not shown
Opt=0       # 0: Standard; 1: Curve always black; 2: Only mosaic (without test)
#########################################################
library(nortest)
####Random generation for SEPD
rsepd=function(n,mu=0,sigma=1,alpha=0.5,p=2){
kp=1/(2*gamma(1+1/p)*p^(1/p))
u=runif(n)
w=rgamma(n,shape=1/p,scale=1)
y=ifelse(u>alpha,1-alpha,-alpha)*(w^(1/p))/gamma(1+1/p)
y=y/kp
A=2*p^(1/p)*((1-alpha)^2-alpha^2)*gamma(2/p)/gamma(1/p)
A2=(2*p^(1/p))^2*((1-alpha)^3+alpha^3)*gamma(3/p)/gamma(1/p)
B=sqrt(A2-A^2)
mu+sigma*(y-A)/B
}
####Density function for SEPD
dsepd=function(x,mu=0,sigma=1,alpha=0.5,p=2){
A=2*p^(1/p)*((1-alpha)^2-alpha^2)*gamma(2/p)/gamma(1/p)
A2=(2*p^(1/p))^2*((1-alpha)^3+alpha^3)*gamma(3/p)/gamma(1/p)
B=sqrt(A2-A^2)
y=A+B*(x-mu)/sigma
kp=1/(gamma(1+1/p)*(2*p^(1/p)))
kp*exp(-(abs(y/(2*ifelse(x<mu-sigma*A/B,alpha,1-alpha)))^p)/p)*B/sigma
}
###Monte Carlo p-value for godness-of-fit statistics
et2_MC=function(siz,nsim,mu,sigma,alpha,p,nsig,test){
ysim=matrix(rsepd(siz*nsim,mu=mu,sigma=sigma,alpha=alpha,p=p),nc=siz)
prova=switch(test,
AD = function(el) ad.test(el)$p.value,
SW = function(el) shapiro.test(el)$p.value,
KS = function(el) lillie.test(el)$p.value)
res=apply(ysim,1,prova)
length(res[res>nsig])/nsim
}
#### Mosaic function
mosaic=function(siz,n,nsim=499,nsig=0.05,test="AD",label=F,Opt=0){
if (n<=1 | n>=50) {
stop("n must be a value between 2 and 49\n")
}
mu=0
sigma=1
if (n%%2==0) n=n+1
cex1=c(1.2,1,0.8,0.7,0.6)
old.par=par(mfrow = c(n,n), xaxt="n", yaxt="n", mar=c(0,0,0,0), cex=cex1[findInterval(n,c(1,5,10,15,25,9999))], xaxs="i", yaxs="i")
s=3.5
ymax=c(0,1/sigma)
j=(log10(50)/log10(2))^(1/(n/2-0.5))
alfa=(0:(n-1))/(n-1)
alfa[alfa==0]=1e-12
alfa[alfa==1]=1-1e-12
p=c(1,2,50)
if (n>3) p=c(1,2^(1/(j^(((n-3)/2):1))),2,2^(j^((1:(n/2-0.5)))))
graf1=function(param,label){
x=seq(from=mu-s*sigma,to=mu+s*sigma,length.out=101)
plot(0,0,xlim=c(mu-s*sigma,mu+s*sigma),ylim=ymax,type="n",axes=F)
pvalue=round(et2_MC(siz=siz,nsim=nsim,mu=mu,sigma=sigma,alpha=param[1],p=param[2],nsig=nsig,test=test),2)
id=findInterval(pvalue,c(0,0.05,0.25,0.5,1))
colo=gray(c(0.9,0.85,0.4,0.2,0))[id]
if(id>1) rect(mu-s*sigma,0,mu+s*sigma,ymax[2],col=colo)
coline=switch(Opt+1, ifelse(id>2,"white","black"),"black","black")
curve(dsepd(x,mu=mu,sigma=sigma,alpha=param[1],p=param[2]),col=coline,add=T)
if (param[1]==0.5 & param[2]==2) box(lwd=2,col="white") else box()
if (label) text(mu,ymax[2]*0.5,round(pvalue,2),col=ifelse(id>2,"white","black"))
}
graf2=function(param,label){
x=seq(from=mu-s*sigma,to=mu+s*sigma,length.out=101)
plot(0,0,xlim=c(mu-s*sigma,mu+s*sigma),ylim=ymax,type="n",axes=F)
curve(dsepd(x,mu=mu,sigma=sigma,alpha=param[1],p=param[2]),col="black",add=T)
box()
}
if (Opt==2) graf=graf2 else graf=graf1
apply(expand.grid(alfa,p),1,graf,label=label)
par(old.par)
}
mosaic(siz,n,nsim,nsig,test,label,Opt)
rm(list = ls())
setwd("E:/Dropbox/Github/Unit-root-test-of-Non-stationary-time-series")
data = read.csv("./datasets/buildingA_15min.csv")
# data = data[,-ncol(data)]
timedate = as.numeric(paste(data[,3], formatC(data[,4], width=4, flag="0"), sep=""))
year = substr(data[,3], 1, 4)
newData = cbind(data, year)
dataVec = data[,5]
plotAll = function(main = "ADF Test")
{
# init
plot(dataVec, type="l", main=main, xlab="", ylab="power consumption(kWh)", axes=FALSE)
# y축 axis
axis(2, dataVec, labels=seq(0, max(dataVec), by=50), at=seq(0, max(dataVec), by=50))
# x축 axis  년도
min2015 = min(which(year == "2015"));	min2016 = min(which(year == "2016"))
min2017 = min(which(year == "2017"));	min2018 = min(which(year == "2018"))
axis(1, c(min2015, min2016, min2017, min2018), labels = c("2015", "2016", "2017", "2018"), line=1)
mtext("Year",1,line=1,at=0.2)
# x축 axis: 월
season = newData[,13]
yearmonth = substr(data[,3], 1, 6)
month201509 = which(yearmonth=="201509");	month201510 = which(yearmonth=="201510");	month201511 = which(yearmonth=="201511");	month201512 = which(yearmonth=="201512")
month201601 = which(yearmonth=="201601");	month201602 = which(yearmonth=="201602");	month201603 = which(yearmonth=="201603");	month201604 = which(yearmonth=="201604")
month201605 = which(yearmonth=="201605");	month201606 = which(yearmonth=="201606");	month201607 = which(yearmonth=="201607");	month201608 = which(yearmonth=="201608")
month201609 = which(yearmonth=="201609");	month201610 = which(yearmonth=="201610");	month201611 = which(yearmonth=="201611");	month201612 = which(yearmonth=="201612")
month201701 = which(yearmonth=="201701");	month201702 = which(yearmonth=="201702");	month201703 = which(yearmonth=="201703");	month201704 = which(yearmonth=="201704")
month201705 = which(yearmonth=="201705");	month201706 = which(yearmonth=="201706");	month201707 = which(yearmonth=="201707");	month201708 = which(yearmonth=="201708")
month201709 = which(yearmonth=="201709");	month201710 = which(yearmonth=="201710");	month201711 = which(yearmonth=="201711");	month201712 = which(yearmonth=="201712")
month201801 = which(yearmonth=="201801");	month201802 = which(yearmonth=="201802")
axis_vec = c(	min(month201509),	min(month201510),	min(month201511),	min(month201512),
min(month201601),	min(month201602),	min(month201603),	min(month201604),	min(month201605),	min(month201606),
min(month201607),	min(month201608),	min(month201609),	min(month201610),	min(month201611),	min(month201612),
min(month201701),	min(month201702),	min(month201703),	min(month201704),	min(month201705),	min(month201706),
min(month201707),	min(month201708),	min(month201709),	min(month201710),	min(month201711),	min(month201712),
min(month201801),	min(month201802))
monthVec = c("01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12")
monthVec = c(monthVec[9:12], monthVec, monthVec, monthVec[1:2])
axis(1, axis_vec, labels = monthVec, line=3)
mtext("Month", 1, line=3, at=0.2)
axis(1, data[,2], labels = data[,2], line=5, lwd.ticks=0.1)
mtext("Index", 1, line=5,at=0.2)
}
